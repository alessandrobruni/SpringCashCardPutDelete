# SpringCashCardPutDelete

<div class="max-w-container mx-auto">
        <div class="xl:grid grid-cols-3 gap-12">
            <div class="rich-text col-span-2">
                <h1>Implementing PUT</h1>

                                    
<p>So far we&rsquo;re able to create and retrieve Cash Cards. A next logical step is the ability to adjust a card balance! How to implement the Update operation in a RESTful API is somewhat of a hot topic, which is what we&rsquo;ll tackle in this lesson.</p>
<p>When we say &ldquo;adjust the balance&rdquo; on a Cash Card, what we really mean is to update the <code>amount</code> on an existing database record. Doing so will entail:</p>
<ul><li>Creating a new endpoint to receive an HTTP request with a verb, URI, and body</li>
<li>Returning an appropriate response from the endpoint for success and error conditions</li>
</ul><p>We&rsquo;re already familiar with the HTTP <code>POST</code> verb, which we used for the Create endpoint. Now let's talk about HTTP <code>PUT</code> and <code>PATCH</code>, and how all three of these are related.</p>
<h2 id="put-and-patch" class="anchored"><a href="#put-and-patch" class="anchor" role="button"></a>PUT and PATCH</h2>
<p>Both <code>PUT</code> and <code>PATCH</code> can be used for updating, but they work in different ways. Essentially, <code>PUT</code> means &ldquo;create or replace the complete record&rdquo;, whereas <code>PATCH</code> means &ldquo;update only some fields of the existing record&rdquo; - in other words, a partial update.</p>
<p>Why would you want to do a partial update? Partial updates free the client from having to load the entire record and then transmit the entire record back to the server. If the record is large enough, this can have a non-trivial impact on performance.</p>
<p>For our application, we&rsquo;ll choose to <strong>not</strong> implement a partial update.</p>
<h2 id="put-and-post" class="anchored"><a href="#put-and-post" class="anchor" role="button"></a>PUT and POST</h2>
<p>There&rsquo;s something we didn&rsquo;t tell you when we wrote the Create endpoint: The HTTP standard does not specify whether the <code>POST</code> or <code>PUT</code> verb is preferred for a Create operation! This is relevant because we&rsquo;ll use the <code>PUT</code> verb for our Update endpoint, so we need to decide whether our API will support using <code>PUT</code> to either Create <em>or</em> Update a resource.</p>
<p>There are different ways to look at the relationship between the <strong>Create</strong> and <strong>Update</strong> operations and how they are implemented in REST using HTTP verbs. In the following sections we discuss it from three different points of view, then summarize what we've covered so far, as a table.</p>
<p>The important takeaway from the following sections is not to memorize all the details, but simply to realize that there are lots of different choices, and that we, as Cash Card API authors, are consciously making decisions about how to implement REST.</p>
<h3>Surrogate and Natural Keys</h3>
<p>Why would we want to use a <code>PUT</code> operation to create a resource? This has to do with the HTTP definition of the two verbs. The difference is subtle. Let&rsquo;s explain it by comparing two different systems: Our <strong>Cash Card API</strong>, and another API that we'll introduce for explanatory purposes, called the <strong>Invoice API</strong>. The Invoice API accepts the Invoice Number as the unique identifier. This is an example of using a <strong>Natural Key</strong> (supplied by the client to the API) instead of a <strong>Surrogate Key</strong> (usually generated by the server, which is what we are doing in our Cash Card API).</p>
<p>The important difference is <strong>whether the URI (which includes the ID of the resource) needs to be generated by the server</strong> or not. Here is how PUT and POST think about it:</p>
<ol><li>If you need the server to return the URI of the created resource (or the data you use to construct the URI), then you must use <code>POST</code>.</li>
</ol><p>This is the case for our Cash Card API: To create a Cash Card, we provide the <code>POST /cashcards</code> endpoint. The actual URI for the created Cash Card depends on the generated ID, and is provided by the server, for example, <code>/cashcards/101</code> if the ID of the created card is 101.</p>
<ol><li>Alternatively, when the resource URI is known at creation time (as is the case in our example Invoice API), you can use <code>PUT</code>.</li>
</ol><p>For the Invoice API, we could write a Create endpoint that accepts requests such as <code>PUT /invoice/1234-567</code>. The corresponding Read call would use the exact same URI: <code>GET /invoice/1234-567</code>.</p>
<h3>Resources and Sub-Resources</h3>
<p>Another way to look at the difference is in terms of <strong>URIs and collections of sub-resources</strong>. This is the language used by the HTTP documentation, so it's good to be familiar with it. Following the above examples, we&rsquo;d find:</p>
<ul><li><p><strong><code>POST</code> creates a sub-resource (child resource) <em>under (after)</em>, or <em>within</em> the request URI</strong>. This is what the Cash Card API does: The client calls the Create endpoint at <code>POST /cashcards</code>, but the actual URI of the created resource contains a generated ID at the end: <code>/cashcards/101</code></p>
</li>
<li><p><strong><code>PUT</code> creates or replaces (updates) a resource <em>at a specific</em> request URI</strong>. For the <code>/invoice</code> example above, the Create endpoint would be <code>PUT /invoice/1234-567</code>, and the URI of the created resource would be the same as the URI sent in the <code>PUT</code> request.</p>
</li>
</ul><h3>Response Body and Status Code</h3>
<p>Related to deciding whether to allow <code>PUT</code> to create objects, you need to decide what the response status code and body should be. Two different options are:</p>
<ul><li>Return <code>201 CREATED</code> (if you created the object), or <code>200 OK</code> (if you replaced an existing object). In this case it's recommended to return the object in the response body. This is useful if data was added to the object by the server (for example, if the server records the creation date).</li>
</ul><p><em>or</em></p>
<ul><li>Return <code>204 NO CONTENT</code>, and an empty response body. The rationale in this case is that since a <code>PUT</code> simply places on object at the URI in the request, the client doesn't need any information back - it knows that the object in the request has been saved, verbatim, on the server.</li>
</ul><h2 id="post-put-patch-and-crud-operations-summary" class="anchored"><a href="#post-put-patch-and-crud-operations-summary" class="anchor" role="button"></a>POST, PUT, PATCH and CRUD Operations - Summary</h2>
<p>The sections above can be summarized using the following table:</p>
<table><thead><tr><th>HTTP Method</th><th>Operation</th><th>Definition of Resource URI</th><th>What does it do?</th><th>Response Status Code</th><th>Response Body</th></tr></thead><tbody><tr><td><strong><code>POST</code></strong></td><td><strong>Create</strong></td><td><strong>Server generates and returns the URI</strong></td><td><strong>Creates a sub-resource ("under" or "within" the passed URI)</strong></td><td><strong><code>201 CREATED</code></strong></td><td><strong>The created resource</strong></td></tr><tr><td><code>PUT</code></td><td>Create</td><td>Client supplies the URI</td><td>Creates a resource (at the Request URI)</td><td><code>201 CREATED</code></td><td>The created resource</td></tr><tr><td><strong><code>PUT</code></strong></td><td><strong>Update</strong></td><td><strong>Client supplies the URI</strong></td><td><strong>Replaces the resource: The entire record is replaced by the object in the Request</strong></td><td><strong><code>204 NO CONTENT</code></strong></td><td><strong>(empty)</strong></td></tr><tr><td><code>PATCH</code></td><td>Update</td><td>Client supplies the URI</td><td>Partial Update: modify only fields included in the request on the existing record</td><td><code>200 OK</code></td><td>The updated resource</td></tr></tbody></table><p>In the Cash Card API, we don&rsquo;t need to allow <code>PUT</code> to create resources. We also have no need to add data on the server side for an Update operation, nor do we need to allow for partial update. So, our <code>PUT</code> endpoint is limited to row 3 of the above table.</p>
<p>The <strong>bold</strong> rows in the above table are implemented by Cash Card API. The non-bold ones are not.</p>
<h2 id="security" class="anchored"><a href="#security" class="anchor" role="button"></a>Security</h2>
<p>One more decision we&rsquo;ll make is how to apply security logic to the new Update operation.</p>
<p>Recall from the Simple Security lesson that we decided to return <code>404 NOT FOUND</code> for <code>GET</code> requests in two cases: nonexistent IDs, and attempted access to cards for which the user isn&rsquo;t authorized. We&rsquo;ll use the same strategy for the Update endpoint, and for similar reasons (we&rsquo;ll go into more details in the lab).</p>
<h2 id="our-api-decisions" class="anchored"><a href="#our-api-decisions" class="anchor" role="button"></a>Our API Decisions</h2>
<p>Phew, that was a lot of decisions! To summarize, we decided:</p>
<ul><li><code>PUT</code> won&rsquo;t support creating a Cash Card.</li>
<li>Our new <strong>Update</strong> endpoint (which we'll build in the upcoming Lab):<ul><li>will use the <code>PUT</code> verb.</li>
<li>accepts a Cash Card, and <strong>replaces</strong> the existing Cash Card with it.</li>
<li>on success, will return <code>204 NO CONTENT</code> with an empty body.</li>
<li>will return a <code>404 NOT FOUND</code> for an unauthorized update, as well as attempts to update nonexistent IDs.</li>
</ul></li>
</ul>





